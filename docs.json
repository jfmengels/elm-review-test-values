[{"name":"NoTestValuesInProductionCode","comment":"\n\n@docs rule\n@docs Configuration, startsWith, endsWith\n\n","unions":[{"name":"Configuration","comment":" Configure how values should be tagged.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"endsWith","comment":" A test-only value's name ends with the given string.\n","type":"String.String -> NoTestValuesInProductionCode.Configuration"},{"name":"rule","comment":" Reports when functions or values meant to be used only in tests are used in production source code.\n\n    config =\n        [ NoTestValuesInProductionCodeTest.rule\n            (NoTestValuesInProductionCodeTest.startsWith \"test_\")\n\n        -- or\n        , NoTestValuesInProductionCodeTest.rule\n            (NoTestValuesInProductionCodeTest.endsWith \"_TESTS_ONLY\")\n        ]\n\nA recurring question around opaque types, is how do you restrict access to constructors so that you can't misuse a data\ntype, while also being able to use it in tests in order to do meaningful tests.\n\n\n## Problematic example\n\nIn the following example, we have two user roles in an opaque `Role`. `Admin` is being protected so that the only way to create one is by\nhaving the server return that the user has that role.\n\n    -- module Role exposing (Role, requestRole)\n\n\n    import Http\n    import Json.Decode as Decode exposing (Decoder)\n\n    type Role\n        = User\n        | Admin\n\n    requestRole : (Role -> msg) -> String -> Cmd msg\n    requestRole onResponse id =\n        Http.get\n            { url = \"https://server.com/user/\" ++ id\n            , expect = Http.expectJson onResponse roleDecoder\n            }\n\n    roleDecoder : Decoder Role\n    roleDecoder =\n        Decode.field \"role\" Decode.string\n            |> Decode.andThen\n                (\\role ->\n                    case role of\n                        \"admin\" ->\n                            Decode.succeed Admin\n\n                        \"user\" ->\n                            Decode.succeed User\n\n                        \"admin\" ->\n                            Decode.fail \"Not a valid role\"\n                )\n\nWith this approach, we have a good foundation to build on, in the sense that it won't be possible for someone to have an\n`Admin` role without the server's consent (the approach could be improved, but for this example it is sufficient).\n\nThe problem is that we know won't be able to write tests that require a role, because it is not possible to construct\nsuch a value in our tests, as we would need to make a HTTP request which `elm-test` doesn't support.\n\nThe common solution is therefore to either expose the `Role` (exposing `Role(..)`) or to expose functions to construct\n`Role`.\n\n    -- module Role exposing (Role, admin, requestRole, user)\n    type Role\n        = User\n        | Admin\n\n    user =\n        User\n\n    admin =\n        Admin\n\nNow the problem is that we lost the foundation we had, where a user could be `Admin` only if the server said they were.\nNow such a case would only be caught during code review where the reviewer would have to make sure the role is never\nabused.\n\n\n## Proposed solution\n\nThe solution I would go for in the previous example would be to expose functions to construct `Role`, but tag them in a\nway that we should only use them in test code. And using this `elm-review` rule, we'd get a guarantee that this is the\ncase.\n\nThose functions are tagged as test-only by their name. You can choose to either have them prefixed or suffixed by a\nset string of your choosing.\n\n\n## Fail\n\n    -- NoTestValuesInProductionCodeTest.startsWith \"test_\"\n    grantAdminRights user =\n        { user | role = Role.test_admin }\n\n    -- NoTestValuesInProductionCodeTest.endsWith \"_TESTS_ONLY\"\n    grantAdminRights user =\n        { user | role = Role.admin_TESTS_ONLY }\n\n\n## Success\n\n    -- module RoleTest exposing (roleTest)\n    roleTest =\n        Test.describe \"Role\"\n            [ Test.test \"admins should be able to delete database \" <|\n                \\() -> Expect.true (canDeleteDatabase Role.test_admin)\n            , Test.test \"users should not be able to delete database \" <|\n                \\() -> Expect.false (canDeleteDatabase Role.test_user)\n            ]\n\nValues marked as test-only can be used in the declaration of other test values.\n\n    -- module User exposing (test_admin_user)\n    test_admin_user =\n        { id = \"001\"\n        , role = Role.test_admin\n        }\n\n\n## Critique\n\nIs this a perfect solution? No. Tagging values is a brittle solution, and it's easy to misname a function (`testadmin`\ninstead of `test_admin` for instance) and lose the guarantees this rule was given you.\n\nIt's not perfect, but I think this brittleness will not be a problem in practice, because even if the rule doesn't\nenforce anything, having something called `testXyz` will likely be good enough to prevent misuse in practice (otherwise\nI don't understand why there so many frameworks would prone \"convention over configuration\" in other ecosystems).\n\n\n## When (not) to enable this rule\n\nThis rule is useful only if you have instances where you wish to add guarantees to the usage of your data types, but\nneed to access internals in the context of your tests.\nAlso, for this rule to work well, the naming convention for test-only values needs to be communicated to the rest of the\nteam or project.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-test-values/example --rules NoTestValuesInProductionCodeTest\n```\n\nThe example this rule uses are the two configurations linked to at the top of the page.\n\n","type":"NoTestValuesInProductionCode.Configuration -> Review.Rule.Rule"},{"name":"startsWith","comment":" A test-only value's name starts with the given string.\n","type":"String.String -> NoTestValuesInProductionCode.Configuration"}],"binops":[]}]